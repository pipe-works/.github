# Reusable Release Please Workflow for pipe-works organization
# Automated semantic versioning and changelog generation
#
# Usage in your repo's .github/workflows/release-please.yml:
#
# name: Release Please
#
# on:
#   push:
#     branches: [main]
#
# jobs:
#   release:
#     uses: pipe-works/.github/.github/workflows/reusable-release-please.yml@main
#     with:
#       release-type: 'python'
#       package-name: 'your-package-name'
#       bump-minor-pre-major: true
#     secrets: inherit
#
# Requirements:
# 1. Create release-please-config.json in repo root
# 2. Create .release-please-manifest.json in repo root
# 3. Use conventional commits (feat:, fix:, docs:, etc.)
#
# See templates in .github/config-templates/

name: Reusable Release Please

on:
  workflow_call:
    inputs:
      release-type:
        description: 'Release type (python, node, rust, go, etc.)'
        required: false
        type: string
        default: 'python'
      package-name:
        description: 'Package name for releases'
        required: true
        type: string
      bump-minor-pre-major:
        description: 'Bump minor for breaking changes pre-1.0 (keeps in 0.x)'
        required: false
        type: boolean
        default: true
      bump-patch-for-minor-pre-major:
        description: 'Bump patch for minor changes pre-1.0'
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  statuses: write

jobs:
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    outputs:
      pr: ${{ steps.release.outputs.pr }}
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}

    steps:
    - name: Run Release Please
      uses: googleapis/release-please-action@v4
      id: release
      with:
        # Use config files for versioning strategy
        config-file: release-please-config.json
        manifest-file: .release-please-manifest.json

    - name: Release Please Output
      if: steps.release.outputs.pr != ''
      run: |
        echo "Release Please created/updated PR"
        echo "PR: ${{ steps.release.outputs.pr }}"

    - name: Release Created
      if: steps.release.outputs.release_created == 'true'
      run: |
        echo "Release created!"
        echo "Tag: ${{ steps.release.outputs.tag_name }}"

  # Trigger CI on release-please branch after PR is created/updated
  # This is needed because GITHUB_TOKEN pushes don't trigger workflows
  trigger-ci:
    name: Trigger CI
    needs: release-please
    if: needs.release-please.outputs.pr != ''
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.trigger.outputs.run_id }}
      head_sha: ${{ steps.trigger.outputs.head_sha }}

    steps:
    - name: Trigger CI workflow and get run ID
      id: trigger
      uses: actions/github-script@v7
      with:
        script: |
          // Parse the PR object from release-please output
          const prData = ${{ needs.release-please.outputs.pr }};
          const branchName = prData.headBranchName;

          console.log(`PR #${prData.number}: ${prData.title}`);
          console.log(`Triggering CI on branch: ${branchName}`);

          // Get the branch's head SHA before triggering
          const { data: ref } = await github.rest.git.getRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: `heads/${branchName}`
          });
          const headSha = ref.object.sha;
          console.log(`Head SHA: ${headSha}`);

          // Set pending status on the commit
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: headSha,
            state: 'pending',
            context: 'All Checks Passed',
            description: 'CI workflow triggered, waiting for completion...'
          });

          // Trigger the CI workflow
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'ci.yml',
            ref: branchName
          });

          // Wait a moment for the workflow to start
          await new Promise(resolve => setTimeout(resolve, 5000));

          // Find the triggered workflow run
          const { data: runs } = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'ci.yml',
            branch: branchName,
            per_page: 5
          });

          const run = runs.workflow_runs.find(r => r.event === 'workflow_dispatch');
          if (run) {
            console.log(`Found CI run: ${run.id}`);
            core.setOutput('run_id', run.id);
          } else {
            console.log('Could not find workflow run, but CI was triggered');
            core.setOutput('run_id', '');
          }
          core.setOutput('head_sha', headSha);

  # Wait for CI to complete and report status back to the PR
  report-status:
    name: Report CI Status
    needs: [release-please, trigger-ci]
    if: needs.trigger-ci.outputs.run_id != ''
    runs-on: ubuntu-latest

    steps:
    - name: Wait for CI and report status
      uses: actions/github-script@v7
      with:
        script: |
          const runId = ${{ needs.trigger-ci.outputs.run_id }};
          const headSha = '${{ needs.trigger-ci.outputs.head_sha }}';

          console.log(`Waiting for CI run ${runId} to complete...`);

          // Poll for completion (max 30 minutes)
          const maxWait = 30 * 60 * 1000;
          const pollInterval = 30 * 1000;
          const startTime = Date.now();

          while (Date.now() - startTime < maxWait) {
            const { data: run } = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            console.log(`Run status: ${run.status}, conclusion: ${run.conclusion}`);

            if (run.status === 'completed') {
              const state = run.conclusion === 'success' ? 'success' : 'failure';
              const description = run.conclusion === 'success'
                ? 'All CI checks passed'
                : `CI failed: ${run.conclusion}`;

              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: headSha,
                state: state,
                context: 'All Checks Passed',
                description: description,
                target_url: run.html_url
              });

              console.log(`Set commit status: ${state}`);
              return;
            }

            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          // Timeout - set error status
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: headSha,
            state: 'error',
            context: 'All Checks Passed',
            description: 'CI workflow timed out'
          });

          core.setFailed('CI workflow timed out after 30 minutes');
